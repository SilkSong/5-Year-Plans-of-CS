## Week 3

2025.12.16

* 已经两个半月没有提交 Git, 也已经几乎相同时间没有记录 iHour 和 iBetter, 今天恢复, 希望以饱满的姿态进入2026年。
* 打算重新把多线程和 JUC 看一遍, 今天重新学习了实现线程的两种方式，一种是继承 `Thread` 类, 一种是实现 `Runnable` 接口, 然后调用 `start` 方法

2025.12.17

* 重新写了下龟兔赛跑的例子, 比之前理解起来容易好多, 虽然开启了两个线程但是如果使用的是同一个 Race 对象，即使 winner 没有被 static 修饰, 也会共享同一个 winnner
* 学习了 `Callable` 接口来实现线程要做的事情, 它有返回值，可以抛出异常，往往用在线程池中

2025.12.18

* 通过继承 Thread 类的例子, 学习了静态代理模式和 lambda 表达式


## Week 4

2025.12.22

* 经过了一个难过的周五, 周六，周日后重新开始学习。学习了线程的六大状态, 以及线程的 `yield` `stop` `sleep` `join` 等各个行为, 了解了几个线程的概念并实验了方法, 如: 优先级, 守护线程, 通过不安全的集合, 买票和银行，实现了三个不安全的案例。

2025.12.23

* 今天比较艰难, 还是坚持完成了每日打卡。主要是 synchronized 关键字, CopyOnWriteArrayList 和死锁的概念

2025.12.24

* 快速了解了生产者消费者问题, 了解了线程间通信的两种方式: 管程法和信号灯法，了解了线程池的基本类和创建方式

2025.12.25

* 重新回顾了一下多线程, 并行与并发, wait 与 sleep
* 前几天开始看 Hello-Agents 教程，从初识智能体, 智能体的定义，分类，行为方式到智能体的发展史，今天看到了大语言模型的基础, 从 N-gram, 到词嵌入, RNN, LSTM 到 transformers。

2025.12.26

* Hello-Agents 看完了第三章, 主要了解了大模型的发展历程和核心架构的演进
* JUC 并发重新学习了 Lock, 生产者和消费者问题以及了解了虚假唤醒


2025.12.27

* 通过项目中传入一个 boolean, 改成传入一个 List<boolean>, 更深刻的体会到了 Java 值传递的机制
* 粗看完了 Hello-Agents 的第四章, 对于 ReAct, Reflection 和 Plan-And-Solve 范式有了初步的了解, 跑完了示例代码。
* 重新复习了静态代理: 其中开启线程的 start0 是 OS层面来调度, 最终回调后线程调用 run 方法
* 重新复习了 lambda 表达式
* 对线程的六种状态有了更深刻的理解
* 对 Lock, Synchronized 关键字对于线程状态的改变, 控制的层面有了更清晰的认识


2025.12.28

* 了解了线程池的创建方法，执行策略, 核心线程数，最大线程数，队列等参数的真实含义
* 复习了生产者与消费者模式, 线程间通信的方式, 特别的, notify 后线程只是从 WAITING 状态变到了 BLOCKED 状态, 只有锁消失后，线程才会变为 RUNNABLE
* 彻底搞弄了虚假唤醒问题, 并且更深刻的理解了 synchronzied 方法和 wait() 会释放锁的特性

2025.12.31

* 2025年的最后一天, 在停了几天后重新开始,希望以一个好的姿态迈入2026年。学习了 Lock 版本的生产者与消费者，实际上就是用 condition 的方法取代了原来的 Object 方法
* 稍微深入的了解了一些并发集合类: `CopyOnWriteArrayList` `CopyOnWriteArraySet` `ConcurrentHashMap` 等, 简单了解了他们 COW 的机制